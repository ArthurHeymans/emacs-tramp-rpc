#+TITLE: TRAMP-RPC Technical Comparison
#+AUTHOR: Arthur Heymans <arthur@aheymans.xyz>
#+DATE: February 2026
#+OPTIONS: toc:3 num:t

* Executive Summary

TRAMP-RPC is a high-performance alternative TRAMP backend that replaces shell command parsing with a binary MessagePack-RPC server. This document provides an in-depth technical comparison between TRAMP-RPC and the original TRAMP implementation (tramp-sh).

Key findings:
- *2-38x faster* for most file operations
- *27x faster* for directory-files-and-attributes (critical for dired)
- *Batching support* enables additional 2-4x speedup for multiple operations
- Multi-hop, macOS, and filesystem watching fully supported

* Architecture Comparison

** Original TRAMP (tramp-sh)

The original TRAMP uses a shell-based architecture:

#+begin_example
                    SSH Connection
┌─────────────┐    ┌───────────────────────────────────────────────────┐
│   Emacs     │    │                 Remote Host                       │
│             │◄──►│  /bin/sh ──► shell commands ──► parse output      │
└─────────────┘    └───────────────────────────────────────────────────┘
#+end_example

*** How Original TRAMP Works

1. *Connection Establishment*: Opens an SSH connection and spawns a remote shell
2. *Command Execution*: For each operation, constructs a shell command string
3. *Output Parsing*: Parses the text output to extract results
4. *Caching*: Uses extensive caching to mitigate round-trip latency

For example, to get file attributes, original TRAMP runs:

#+begin_src sh
stat --format='...' /path/to/file 2>/dev/null
#+end_src

And then parses the formatted output string.

*** Original TRAMP Source Structure

The original TRAMP codebase (~/src/tramp) is organized as:

| File               | Lines  | Purpose                                |
|--------------------+--------+----------------------------------------|
| tramp.el           | ~5500  | Core TRAMP infrastructure              |
| tramp-sh.el        | ~6500  | SSH/shell-based backend implementation |
| tramp-cache.el     | ~600   | Caching layer                          |
| tramp-cmds.el      | ~900   | Interactive commands                   |
| tramp-message.el   | ~500   | Logging/debugging                      |
| Other backends     | ~5000  | GVFS, ADB, containers, etc.            |

Key characteristics:
- *Shell-dependent*: Requires a Bourne-compatible shell on remote
- *Text parsing*: Heavy use of regex to parse command output
- *Quoting complexity*: Must handle shell metacharacter escaping
- *Multiple round-trips*: Many operations require several commands

** TRAMP-RPC Architecture

TRAMP-RPC uses a binary RPC server architecture:

#+begin_example
                      SSH Connection
┌─────────────┐      ┌───────────────────────────────────────────────┐
│   Emacs     │      │              Remote Host                      │
│ (tramp-rpc) │◄────►│  tramp-rpc-server (Rust binary)               │
│             │      │       │                                       │
│ MessagePack │      │       ├─► Native syscalls (stat, read, ...)   │
│ RPC Protocol│      │       └─► Process spawning (tokio)            │
└─────────────┘      └───────────────────────────────────────────────┘
#+end_example

*** How TRAMP-RPC Works

1. *Binary Deployment*: On first connection, deploys a pre-compiled binary
2. *Single Process*: The server handles all operations via RPC
3. *Native Operations*: Uses direct syscalls instead of shell commands
4. *Structured Data*: Returns MessagePack responses, no parsing needed

For example, to get file attributes, TRAMP-RPC sends (MessagePack-encoded):

#+begin_src elisp
((version . "2.0") (id . 1) (method . "file.stat") (params . ((path . "/path/to/file"))))
#+end_src

And receives (MessagePack-encoded):

#+begin_src elisp
((version . "2.0") (id . 1) (result . ((type . "file") (size . 1234) (mode . 420) ...)))
#+end_src

*** TRAMP-RPC Source Structure

| Component                  | Lines  | Purpose                                  |
|----------------------------+--------+------------------------------------------|
| lisp/tramp-rpc.el          | ~2450  | Core RPC communication & file handlers   |
| lisp/tramp-rpc-process.el  | ~1050  | Async process & PTY support              |
| lisp/tramp-rpc-magit.el    | ~780   | Magit/Projectile optimizations & caching |
| lisp/tramp-rpc-deploy.el   | ~950   | Binary deployment & version management   |
| lisp/tramp-rpc-advice.el   | ~330   | Advice functions for process/VC/eglot    |
| lisp/tramp-rpc-protocol.el | ~190   | MessagePack-RPC protocol implementation  |
| server/src/main.rs         | ~160   | Server entry point (Rust)                |
| server/src/handlers/       | ~2850  | RPC method implementations               |
| server/src/protocol.rs     | ~540   | Protocol types & serialization           |
| server/src/watcher.rs      | ~320   | Filesystem watching (inotify/kqueue)     |

Key characteristics:
- *Shell-independent*: Only needs SSH transport
- *Structured responses*: No text parsing required
- *Single round-trip*: Most operations complete in one request
- *Concurrent processing*: Server handles multiple requests in parallel
- *Multi-hop*: SSH ProxyJump for chained connections

* Protocol Comparison

** Original TRAMP Protocol

Original TRAMP operates via text-based shell interaction:

#+begin_src
Emacs → SSH → Shell prompt
Emacs sends: "test -e /path/to/file && echo true || echo false\n"
Shell returns: "true\n"
Emacs parses: result = (string= output "true")
#+end_src

Challenges:
- Must handle different shell behaviors (bash, zsh, ash, etc.)
- Need to escape special characters in paths
- Output parsing can be fragile
- Each command requires shell prompt synchronization

** TRAMP-RPC Protocol

TRAMP-RPC uses MessagePack-RPC over stdin/stdout with length-prefixed binary framing:

#+begin_src
Emacs → SSH → tramp-rpc-server stdin
Request: <length-prefix><msgpack: {version:"2.0",id:1,method:"file.exists",params:{path:"/path"}}>
Response: <length-prefix><msgpack: {version:"2.0",id:1,result:true}>
#+end_src

Advantages:
- Deterministic binary protocol
- No shell quoting issues
- Native binary data support (no base64 overhead)
- Support for concurrent/pipelined requests

*** RPC Methods

TRAMP-RPC exposes these method categories:

**** File Operations
| Method             | Parameters              | Returns                            |
|--------------------+-------------------------+------------------------------------|
| file.stat          | path, lstat             | FileAttributes (or null if absent) |
| file.stat_batch    | paths, lstat            | [FileAttributes or null]           |
| file.executable    | path                    | boolean                            |
| file.truename      | path                    | string (canonical path)            |
| file.read          | path, offset?, length?  | {content: binary, size: int}       |
| file.write         | path, content, append?  | {written: int}                     |
| file.copy          | src, dest, preserve?    | boolean                            |
| file.rename        | src, dest, overwrite?   | boolean                            |
| file.delete        | path, force?            | boolean                            |
| file.set_modes     | path, mode              | boolean                            |
| file.set_times     | path, mtime             | boolean                            |
| file.make_symlink  | target, link_path       | boolean                            |
| file.make_hardlink | src, dest               | boolean                            |
| file.chown         | path, uid, gid          | boolean                            |

**** Directory Operations
| Method           | Parameters               | Returns                  |
|------------------+--------------------------+--------------------------|
| dir.list         | path, include_attrs      | [{name, type, attrs?}]   |
| dir.create       | path, parents?           | boolean                  |
| dir.remove       | path, recursive?         | boolean                  |
| dir.completions  | directory, prefix        | [string]                 |

**** Process Operations
| Method            | Parameters                   | Returns                    |
|-------------------+------------------------------+----------------------------|
| process.run       | cmd, args, cwd, env?, stdin? | {exit_code, stdout, stderr} |
| process.start     | cmd, args, cwd, env?         | {pid}                      |
| process.read      | pid, timeout_ms?             | {stdout, stderr, exited}   |
| process.write     | pid, data                    | {written}                  |
| process.kill      | pid, signal?                 | boolean                    |
| process.close_stdin | pid                        | boolean                    |
| process.list      | (none)                       | [{pid, cmd, running}]      |
| process.start_pty | cmd, args, cwd, rows, cols   | {pid, tty_name}            |
| process.read_pty  | pid, timeout_ms?             | {output, exited}           |
| process.write_pty | pid, data                    | {written}                  |
| process.resize_pty| pid, rows, cols              | boolean                    |
| process.kill_pty  | pid, signal?                 | boolean                    |
| process.close_pty | pid                          | boolean                    |
| process.list_pty  | (none)                       | [{pid, cmd, running}]      |

**** System Operations
| Method              | Parameters | Returns                           |
|---------------------+------------+-----------------------------------|
| system.info         | (none)     | {home, uid, gid, username, ...}   |
| system.getenv       | name       | string or null                    |
| system.expand_path  | path       | string (tilde expanded)           |
| system.statvfs      | path       | {total, free, available}          |
| system.groups       | (none)     | [{gid, name}]                     |

**** Batch/Parallel Operations
| Method                | Parameters                      | Returns             |
|-----------------------+---------------------------------+---------------------|
| batch                 | {requests: [{method, params}]}  | {results: [...]}    |
| commands.run_parallel | {commands: [{cmd, args, cwd}]}  | [{exit_code, stdout, stderr}] |
| ancestors.scan        | {path, markers}                 | {found: [{marker, directory}]} |

**** Filesystem Watch Operations
| Method       | Parameters     | Returns                   |
|--------------+----------------+---------------------------|
| watch.add    | path           | boolean                   |
| watch.remove | path           | boolean                   |
| watch.list   | (none)         | [string]                  |

The server also pushes ~fs.changed~ notifications (no id) when watched directories change.

* Performance Analysis

** Benchmark Results

Tests performed on WiFi network between two Linux hosts (x220-nixos target).

*** File Operation Benchmarks

| Operation            | RPC (median)  | SSH (median)  | Speedup  |
|----------------------+---------------+---------------+----------|
| connection-setup     | 31 ms         | 1.17 s        | *38.2x*  |
| file-exists          | 3.3 ms        | 38.8 ms       | *11.9x*  |
| file-attributes      | 3.4 ms        | 23.3 ms       | 6.8x     |
| file-read            | 7.7 ms        | 20.2 ms       | 2.6x     |
| file-write           | 74.2 ms       | 219.9 ms      | 3.0x     |
| directory-files      | 12.1 ms       | 37.2 ms       | 3.1x     |
| dir-files-attrs      | 3.5 ms        | 95.9 ms       | *27.1x*  |
| process-file (ls)    | 11.4 ms       | 27.0 ms       | 2.4x     |
| process-file (cat)   | 8.9 ms        | 27.6 ms       | 3.1x     |
| copy-file            | 43.1 ms       | 192.0 ms      | *4.5x*   |
| multi-stat (10x)     | 37.6 ms       | 304.7 ms      | *8.1x*   |
| seq-mixed-ops        | 15.2 ms       | 93.9 ms       | 6.2x     |

*** Batch Operation Benchmarks (RPC only)

| Operation            | Sequential   | Batched     | Speedup |
|----------------------+--------------+-------------+---------|
| 10x file.stat        | 37.6 ms      | 9.1 ms      | *4.1x*  |
| 5x mixed ops         | 15.2 ms      | 6.5 ms      | *2.4x*  |

*** Git/VC Operation Benchmarks (Linux kernel repo)

| Operation            | RPC (median)  | SSH (median)  | Speedup |
|----------------------+---------------+---------------+---------|
| git rev-parse        | 5.5 ms        | 29.1 ms       | *5.3x*  |
| git status           | 240 ms        | 297 ms        | 1.2x    |
| git branch           | 7.4 ms        | 19.7 ms       | *2.7x*  |
| git log --oneline    | 10.1 ms       | 33.2 ms       | *3.3x*  |
| git diff --stat      | 9.1 ms        | 19.4 ms       | 2.1x    |
| dir-files (root)     | 15.6 ms       | 92.2 ms       | *5.9x*  |
| file-attrs           | 18.0 ms       | 25.0 ms       | 1.4x    |
| magit-refresh-sim    | 327 ms        | 338 ms        | 1.0x    |

** Performance Analysis

*** Why TRAMP-RPC is Faster

1. *Reduced Protocol Overhead*
   - Original: prompt wait → send command → wait for output → parse
   - RPC: send request → receive response (single round-trip)

2. *Native Syscalls*
   - Original: ~stat --format='...' file~ → parse text
   - RPC: ~stat()~ syscall → MessagePack response

3. *No Shell Quoting*
   - Original: Must escape paths with special characters
   - RPC: Paths are binary data, no escaping needed

4. *Batch Operations*
   - Original: N operations = N round-trips
   - RPC: N operations = 1 round-trip (with batch endpoint)

5. *Concurrent Processing*
   - Original: Sequential command execution
   - RPC: Tokio async runtime processes requests concurrently

*** Where Original TRAMP Can Be Faster

1. *Cold Connection*
   - RPC requires binary deployment on first connect
   - Subsequent connections are fast due to ControlMaster reuse

2. *Cached Operations*
   - Original TRAMP's aggressive caching can make repeated operations instant
   - RPC also caches, but the magit module adds additional TTL-based caching and prefetch

* Implementation Details

** Server Implementation (Rust)

The server is implemented in Rust using Tokio for async I/O:

#+begin_src rust
#[tokio::main]
async fn main() {
    let stdin = tokio::io::stdin();
    let stdout = tokio::io::stdout();

    // Read length-prefixed MessagePack frames
    loop {
        let len = read_u32_be(&mut stdin).await;
        let payload = read_exact(&mut stdin, len).await;
        let request: Request = rmp_serde::from_slice(&payload);

        // Process request concurrently
        tasks.spawn(async move {
            let response = dispatch(&request).await;
            send_response(&mut stdout, &response).await;
        });
    }
}
#+end_src

Key design decisions:

1. *Async I/O*: Uses Tokio for non-blocking file and process operations
2. *Concurrent Request Processing*: Multiple requests processed in parallel via JoinSet
3. *Static Binary*: Built with musl for maximum portability (Linux)
4. *Size Optimization*: LTO, strip, panic=abort, opt-level "z" (~850KB binary)

** Emacs Integration

The Emacs side implements a complete TRAMP backend:

#+begin_src elisp
(defconst tramp-rpc-file-name-handler-alist
  '((file-exists-p . tramp-rpc-handle-file-exists-p)
    (file-attributes . tramp-rpc-handle-file-attributes)
    (insert-file-contents . tramp-rpc-handle-insert-file-contents)
    (write-region . tramp-rpc-handle-write-region)
    ;; ... 50+ handlers
    ))
#+end_src

Key features:

1. *Foreign File Name Handler*: Registered as a TRAMP foreign handler
2. *Connection Sharing*: Uses SSH ControlMaster for connection reuse
3. *Async Process Support*: Full ~make-process~ implementation with polling
4. *PTY Support*: Terminal emulator integration (vterm, eat)
5. *Batch/Pipeline Support*: Multiple operations in single round-trip

** Binary Deployment

On first connection, TRAMP-RPC:

1. Detects remote architecture (~uname -m~, ~uname -s~)
2. Selects appropriate pre-compiled binary (from local cache or GitHub Releases)
3. Transfers via scp (scpx method) with retry support
4. Verifies SHA256 checksum
5. Makes executable and stores in ~/.cache/tramp-rpc/

#+begin_src elisp
(defun tramp-rpc-deploy-ensure-binary (vec)
  "Ensure the tramp-rpc-server binary is available on remote VEC."
  (let ((bootstrap-vec (tramp-rpc-deploy--bootstrap-vec vec)))
    (if (tramp-rpc-deploy--remote-binary-exists-p bootstrap-vec)
        ;; Already deployed
        (tramp-file-local-name (tramp-rpc-deploy--remote-binary-path bootstrap-vec))
      ;; Deploy now
      (let ((arch (tramp-rpc-deploy--detect-arch bootstrap-vec)))
        (tramp-rpc-deploy--transfer-binary bootstrap-vec arch)))))
#+end_src

* Feature Comparison Matrix

| Feature                    | Original TRAMP | TRAMP-RPC             |
|----------------------------+----------------+-----------------------|
| File operations            | Yes            | Yes                   |
| Directory operations       | Yes            | Yes                   |
| Synchronous processes      | Yes            | Yes                   |
| Async processes            | Yes            | Yes                   |
| PTY/terminal support       | Yes            | Yes                   |
| VC integration             | Yes            | Yes                   |
| Multi-hop connections      | Yes            | Yes (via ProxyJump)   |
| Magit/Projectile prefetch  | No             | Yes (parallel)        |
| Filesystem watching        | No             | Yes (inotify/kqueue)  |
| Windows remote hosts       | Yes            | No                    |
| macOS remote hosts         | Partial        | Yes                   |
| Linux remote hosts         | Yes            | Yes                   |
| Batch operations           | No             | Yes                   |
| Request pipelining         | No             | Yes                   |
| Binary data handling       | Via encoding   | Native binary         |
| Shell required on remote   | Yes            | No                    |
| Additional binary required | No             | Yes (~850KB)          |
| Direnv support             | No             | Yes (cached)          |

* When to Use Each

** Use Original TRAMP When:

- Connecting to Windows remote hosts
- Remote host architecture not supported (non x86_64/aarch64 Linux or macOS)
- Minimizing remote system requirements (no binary deployment)

** Use TRAMP-RPC When:

- Performance is critical (editing, VC operations, dired)
- Working with many small files (source code)
- Using magit or other VC tools intensively (parallel prefetch)
- Running many remote commands (compilation, testing)
- Using multi-hop connections (ProxyJump is cleaner than ad-hoc methods)
- Need filesystem watching for cache invalidation

* Future Directions

1. *Incremental File Sync*: rsync-like differential updates
2. *Compression*: Optional compression for large transfers
3. *MELPA Package*: Publish to MELPA for easier installation

* Conclusion

TRAMP-RPC represents a fundamentally different approach to remote file access in Emacs. By replacing shell command parsing with a purpose-built binary protocol, it achieves significant performance improvements for the most common operations while maintaining full compatibility with Emacs' file handling APIs.

The trade-off is the requirement for a pre-compiled binary on the remote host (~850KB), which limits platform support compared to original TRAMP's shell-based universality. For Linux and macOS workflows (x86_64 and aarch64), which represent the majority of development use cases, TRAMP-RPC offers a compelling performance advantage with features like multi-hop support, magit prefetch, and filesystem watching.
